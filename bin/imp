#!/usr/bin/env perl
use warnings;
use strict;
no warnings 'qw';

use Carp;
use Getopt::Long qw(:config no_ignore_case);
use Pod::Usage;
use Log::Log4perl qw(:no_extra_logdie_message);
use Log::Log4perl::Level;

use File::Basename;
use File::Which;
use File::Temp 'tempdir';
use FindBin '$RealBin';

use Graph;

use Data::Dumper;
$Data::Dumper::Sortkeys = 1;
use Fasta::Parser;
use Fastq::Parser;
use Sam::Parser;
use Sam::Alignment ':flags';

##---------------------------------------------------------------------------##
# Globals

our $VERSION = "0.3.0";

our $ID = 'imp';

# get a logger
my $L = Log::Log4perl::get_logger();

Log::Log4perl->init( \(q(
	log4perl.rootLogger                     = INFO, Screen
	log4perl.appender.Screen                = Log::Log4perl::Appender::Screen
	log4perl.appender.Screen.stderr         = 1
	log4perl.appender.Screen.layout         = PatternLayout
	log4perl.appender.Screen.layout.ConversionPattern = [%d{yy-MM-dd HH:mm:ss}] [).$ID.q(] %m%n
)));

##----------------------------------------------------------------------------##
# IDEA

# binaries
#  SeqFilter
#  bwa
#  samtools

# read seqs
# fastq to fasta
# tmp files in /dev/shm/imp-XXXXX or fallback to /tmp

##----------------------------------------------------------------------------##
# Options

my %opt = (
           samtools_path => '',
           bwa_path => $RealBin.'/../util/bwa/',
           threads => 1,
           term_ignore_length => 5,
           bwa_opt => [qw(-a -D0 -y10 -r 1 -T 30 -W40 -L0,0)],
#           bwa_opt => [qw(-a -D0 -e -T 0 -W40 -L0,0)],
           dir => '.',
           out => $ID,
           tmp => (-d '/dev/shm' ? '/dev/shm' : '/tmp'),
           min_score => 0,
           max_trans_depth => 20,
          );

GetOptions(                     # use %opt (Cfg) as defaults
           \%opt, qw(
                        dir=s
                        out=s
                        threads=i
                        frg|fragments=s
                        ref|reference=s
                        samtools-path=s
                        keep|keep-temporary-files!
                        version|V!
                        help|h!
                        quiet!
                        debug|D!
                        sif=s
                   )
          ) or $L->logcroak('Failed to "GetOptions"');

$opt{dir} ||= '.';

# help
$opt{help} && pod2usage(1);

# version
if ($opt{version}) {
    print "$VERSION\n";
    exit 0;
}

# debug level
$opt{quiet} && $L->level($WARN);
$opt{debug} && $L->level($DEBUG);

$L->info("Checking tools");

check_binary(bin('samtools'), ["--version", "1.1"]);
check_binary(bin('bwa'));


##----------------------------------------------------------------------------##
# tmp dir

my $tmp = tempdir(
                  "imp-XXXXXX",
                  DIR => $opt{tmp},
                  CLEANUP => $opt{keep} ? 0 : 1,
                 );

##----------------------------------------------------------------------------##
# load fragments
#  early to check ids etc..

my $frg = "$tmp/frg.faq";
unless($opt{frg}){
    $L->info("Loading fridge < STDIN");
    my $c;
    open(FRG, '>', $frg) or die "$! $opt{frg}";
    print FRG $c while read(STDIN, $c, 100000);
    close FRG;
}else{
    $L->info("Loading fridge < $opt{frg}");
    $opt{frg} = File::Spec->rel2abs($opt{frg});
    qx(ln -s $opt{frg} $frg);
}

$L->logdie("Empty input") unless -s $frg;

my %frg = read_frg($frg);


##----------------------------------------------------------------------------##
# index chunk
$L->info("Indexing ingredients");

# get overlaps
my $sam_cmd;

my $bwa_index_cmd = $opt{bwa_path}."bwa index $frg $frg 2>$frg.idx.log";
$L->debug($bwa_index_cmd);
qx($bwa_index_cmd);
$L->logdie("bwa failed: $?\n", do { local $/; local @ARGV = ("$frg.idx.log") ; <> }) if $?;


##----------------------------------------------------------------------------##
# map & construct graph
$L->info("Processing recipe");

my $bam = "$tmp/inf.bam";
open(BAM, "| samtools view -b /dev/fd/0 > $bam") or die "$!";


$sam_cmd = $opt{bwa_path}."bwa mem -e -t $opt{threads} @{$opt{bwa_opt}} $frg $frg 2>$frg.bwa.log";
$L->debug($sam_cmd);
open(my $sam_oh, "-|", $sam_cmd) or $L->logdie($!);

# init input stream parser
my $sp = Sam::Parser->new(fh => $sam_oh);

my %l;
my $G = Graph->new(
                   directed => 0,
                  );


# Store seq lengths
while (my %h = $sp->next_header_line('SQ')) {
    $l{$h{SN}} = $h{LN};
    print BAM $h{raw};
}

my %sif;

my $contained;
my $qid_prev = '';
my %contained;

while (my $a = $sp->next_aln) {

    print BAM $a;

    my ($rid,$qid) = ($a->rname, $a->qname);

    # ignore self hit
    next if $qid eq $rid;

    # short-cut if contained
    if($qid ne $qid_prev){ # new query
        $qid_prev = $qid;
        $contained = 0;
    }else{
        next if $contained;
    }

    my $score = scalar $a->opt('AS');
    next unless $opt{min_score} < $score;


    my($qprel, $qsufl) = (0,0);
    # query
    my ($o,$t) = $a->cigar =~ /^(\d+)(\w)/;
    $qprel = $o if ($t eq "S" || $t eq "H");
    ($o,$t) = $a->cigar =~ /(\d+)(\w)$/;
    $qsufl = $o if ($t eq "S" || $t eq "H");

    my ($q5,$q3,$r5,$r3);

    # are alignment borders terminal?
    $q5 = $r3 = $qprel < $opt{term_ignore_length} || 0;
    $q3 = $r5 = $qsufl < $opt{term_ignore_length} || 0;

    # my %type = ( "00" => "int", "01" => "5'p", "10" => "3'p", "11" => "con");
    # print OVL join("\t", $qid, $rid, scalar $a->opt('AS'), $a->cigar, $type{$q5.$q3}, $qprel, $qsufl, $a->is(REVERSE_COMPLEMENT) ? "r" : "f"),"\n";

    # contained
    if($q5 && $q3){
        $contained = 1;
        $contained{$qid} = 1;
        $G->set_edge_attribute($rid, $qid , "ovl", {
                                                    score => scalar $a->opt('AS'),
                                                    idy => undef, # nyi
                                                    len => undef, # nyi
                                                    adir => "=",
                                                    bdir => ':',
                                                    aoff => [''],
                                                    boff => [''],
                                                   });
        next;
    }

    # ignore $qid<$rid representation
    next if $qid le $rid;

    # non-terminal alignment
    next unless ($q5 xor $q3);

    if ($a->is(REVERSE_COMPLEMENT)) {
        ($q5,$q3) = ($q3,$q5)
    }

    my %ovl = (
               score => scalar $a->opt('AS'),
               idy => undef, # nyi
               len => undef, # nyi
               adir => $r5 ? '<' : '>',
               bdir => $q5 ? '<' : '>',
               boff => [$r3 ? (-$qsufl) : (0, $qprel)],
              );

    if ($r5) {
        # extremely ugly
        # TODO: make bwa return aln length or sufl length of ref as opt
        my $ovll;
        my $cigar = $a->cigar;
        while ($cigar =~ /(\d+)[MD]/g) {
            $ovll += $1;
        }
        ;

        $ovl{aoff} = [(-($l{$rid} - ($a->pos-1) - $ovll))];
    } else {
        $ovl{aoff} = [(0, $a->pos-1)];
    }

    $G->set_edge_attribute($rid, $qid , "ovl", \%ovl);

}

close BAM;

my $bam_sorted = "$tmp/inf.sorted";
qx(samtools sort $bam $bam_sorted);
$L->logdie("samtools sort failed: $?\n") if $?;
$bam = $bam_sorted.'.bam';
qx(samtools index $bam);
$L->logdie("samtools index failed: $?\n") if $?;

##----------------------------------------------------------------------------##
# refine graph
$L->info("Seasoning dishes");

# isolates (shouldn't happen)
my @isolates = $G->isolated_vertices();
print STDERR Dumper({isolates => \@isolates}) if @isolates;

foreach my $v (keys %contained) {
    $G->delete_vertex($v);
}


##----------------------------------------------------------------------------##
# pop cycles
$L->info("Popping bubbles");

my @trans_edges;
foreach my $e ($G->edges){
    # at least
    push @trans_edges, $e if transitive_edge_path($G, @$e);
}

foreach my $e (@trans_edges){
    $G->delete_edge(@$e);
    # tag trans edges for debug
    # my $ovl = $G->get_edge_attribute(@$e , "ovl");
    # $ovl->{adir} .= 'x';
    # $ovl->{bdir} = 'x'.$ovl->{bdir};

    # $G->set_edge_attribute(@$e, "ovl", $ovl);

}


# TODO: make this smarter by maybe removing/collapsing parallel edges - would
# speed up longest path search

# while (my @c = $G->find_a_cycle) {
#     my @e;
#     for(my $i=0; $i<@c; $i++){
#         if(substr($c[$i],0,-1) ne substr($c[$i+1],0,-1)){
#             @e = @c[$i, $i+1];
#             last;
#         }
#     }

#     Die "Impenetrable bubble!\n" unless @e;

#     #$sif{$e[0] lt $e[1] ? "$e[0] $e[1]" : "$e[1] $e[0]"} = 'popped' if $opt{sif};

#     $L->debug("popping @e");
#     $G->delete_edge(@e);

#     foreach my $v(@e){
#         my $u = substr($v,-1) eq 5 ? substr($v,0,-1).'3' : substr($v,0,-1).'5';
#         if($G->degree($u) == 1){
#             $G->delete_vertices($v, $u);
#             $L->debug("deleting singleton $v $u");
#         }
#     }
# }


##----------------------------------------------------------------------------##
#

#$L->info("Checking the hood");

# remove singletons from graph
my @ccs = sort{scalar @$a <=> scalar @$b}$G->connected_components();
# not explicitly necessary, if just skipped during bbp search
# while(@{$ccs[0]} < 3){
#     $G->delete_vertices(@{$ccs[0]});
#     shift @ccs; # pop singletons
# };


##----------------------------------------------------------------------------##
# synthesis backbone
$L->info("Going the extra mile");

my @bbps; # backbone paths
foreach my $cc (reverse @ccs){ # largest first
    next unless @$cc > 1; # singletons

    my $bbp = longest_path_at($G, $cc->[0], 1); # no need to unvisit - every cc
                                                # is only traversed once
#    my $bbp = [$G->longest_path];
    push @bbps, $bbp;
}

# while(my @bbp = $G->longest_path){
#     last if @bbp < 2;
#     push @bbps, \@bbp;
#     $G->delete_vertices($G->all_neighbours($bbp[0]));
# }

print STDERR Dumper(\@bbps);

foreach my $bbp (@bbps){
    for(my $i=0; $i<@$bbp-1;$i++){
        my $ovl = $G->get_edge_attribute($bbp->[$i], $bbp->[$i+1], "ovl");
        $ovl->{adir} .= 'B';
        $ovl->{bdir} = 'B'.$ovl->{bdir};
        $G->set_edge_attribute($bbp->[$i], $bbp->[$i+1], "ovl", $ovl);

    }
}

$L->info("Synthesizing products (".@bbps.")");
graph2sif($G, $opt{sif}) if $opt{sif};
exit;

my $pc = 0;

# start from exterior nodes
foreach (@bbps) {
    my @p = @$_;
    $pc++;                      # path counter
    my $id;
    my $rc_pr = 0;
    my $rc_po = 0;

    die "unknown $id\n", Dumper([keys %frg]) unless exists $frg{$id};
    my $ctg = $frg{$id};
    $ctg->reverse_complement if $rc_pr;
    #$L->debug($ctg->seq);

    $L->debug(Dumper(\@p));
    my $off;
    for (my $i=2; $i<@p; $i+=2) {
        $L->debug(Dumper([@p[($i-1)..($i+2)]]));
        my $id = substr($p[$i], 0, -2);
        my $rc_r = substr($p[$i],-1) eq 3 ? 1 : 0;

        my $ovl = $G->get_edge_attribute($p[$i-1], $p[$i], "ovl");

        my $rc_o = $ovl->{rc} ? 1 : 0;
        my $rc_q = $ovl->{$p[$i]."_rc"} ? 1 : 0;

        my $frg = $frg{$id}->new;
        my $ohl = $ovl->{$p[$i]};

        $L->debug("$rc_r $rc_o $rc_q [@$ohl]");

        if ($rc_r xor $rc_q) {
            $L->debug("ohl->rc");
            @$ohl = @$ohl == 2 ? ($ohl->[1] * -1) : (0, $ohl->[0] * -1)
        }

        if ($rc_r) {
            $L->debug("frg->rc");
            $frg->reverse_complement;
        }

        $rc_pr = $rc_r;
        $rc_po = $rc_o;

        $off+= abs($_) for @$ohl;
        #$L->debug(" " x abs($off), $frg->seq);
        my $suf = $frg->substr_seq($ohl);

        #$L->debug(" " x length($ctg->seq), $suf->seq);
        $ctg .= $suf;
    }

    $L->debug("[$pc/".@ccs."] ".(@p/2)." fragments, ".length($ctg->seq)." bp");

    print $ctg;
    $G->delete_vertices(@p);
}



##----------------------------------------------------------------------------##

=head2 edge_transitive_path

=cut

sub transitive_edge_path{
    my ($G, $u, $v) = @_;

    my @n = grep{$_ ne $v}($G->neighbours($u));
    return unless @n;

    my $x;
    my $o1 = $G->get_edge_attribute($u, $v, "ovl");

    foreach my $n (@n){
        if(grep{$_ eq $v}($G->neighbours($n))){
            my $o2 = $G->get_edge_attribute($u, $n, "ovl");
            my $o3 = $G->get_edge_attribute($n, $v, "ovl");

            # tau.out.g != tau'.out.g
            my $tog2 = $n lt $u ? $o2->{adir} : $o2->{bdir};
            my $tog3 = $n lt $v ? $o3->{adir} : $o3->{bdir};

            # pi.out.f == tau.out.f
            my $pof = $o1->{adir};
            my $tof = $u lt $n ? $o2->{adir} : $o2->{bdir};


            # pi.out.h == tau'.out.h
            my $poh = $o1->{bdir};
            my $toh = $v lt $n ? $o3->{adir} : $o3->{bdir};

            #print Dumper(["$u, $n, $v", $o1, $o2, $o3, "$tog2 == $tog3", "$pof != $tof","$poh != $toh" ]);

            next if $tog2 eq $tog3;
            next if $pof ne $tof;
            next if $poh ne $toh;

            $x = $n;
            last;
        }
    }
    return $x ? ($u, $x, $v) : undef;
}

=head2 alternative_path

Breadth first search.

=cut

sub alternative_path{
    my ($G, $u, $v, $max_dist) = @_;
    return unless $G->has_edge($u, $v);
    return unless $G->degree($u) > 1 && $G->degree($v) > 1;
    $G->set_vertex_attribute($u, "visited", 1);

    # set up initial queue
    my @Q = grep{$_ ne $v}($G->neighbours($u));
    $G->set_vertex_attribute($_, "visited", 1) for @Q;
    my @Qcache;
#    $G->set_edge_attribute($u, $_, "visited", 1) for @Q;

    my $re;
    while(@Q){
        my @unvisited =  grep{
            ! $G->get_vertex_attribute($_, "visited")
        }($G->neighbours($Q[0]));
        print STDERR Dumper(\@Q);

        if (@unvisited) {
            if (grep{$_ eq $v}(@unvisited)) {
                $re = 1;
                last;
            }            ;
            last unless $max_dist--;

            $G->set_vertex_attribute($_, "visited", 1) for @unvisited;
            push @Q, @unvisited;
        }

        push @Qcache, shift @Q;
    }

    # unvisit to allow recomputation
    $G->set_vertex_attribute($_, "visited", 0) for ($u, $v, @Qcache);

    return $re;
}

=head2 longest_path_at

Compute the longest path in the connected component holding $v. The resulting
does not necessarily include $v.

  my $lp = longest_path_at($g,$v);

=cut

sub longest_path_at{
    my ($G,$v) = @_;
    my $p1 = longest_path_from($G, $v);
    return longest_path_from($G, $p1->[0]);
}

=head2 longest_path_from

Compute the longest path starting given vertex $v. $v will be the last element
of the path, the first element is farthest away.

  my $v_to_furthest = longest_path_from($g,$v);
  my $furthest = $v_to_furthest->[0];

=cut

sub longest_path_from{
    my ($G,$v,$deep) = @_;

    $G->set_vertex_attribute($v, "visited", 1);


    my $unvisited = [ grep{
        ! $G->get_vertex_attribute($_, "visited")
    }($G->successors($v)) ];

    return [$v] if @$unvisited < 1;

    my $longest_path = [];

    foreach my $u (@$unvisited){
        my $path = longest_path_from($G, $u, 1); # deep node
        $longest_path = $path if @$path > @$longest_path;
    }

    push @$longest_path, $v;

    if(! $deep){ # unvisit to allow recomputation
        $G->set_vertex_attribute($_, "visited", 0) for $G->vertices;
    }

    return $longest_path;
}

sub random_path{
    my $G = shift;
    my $vr = $G->random_vertex;

    my @path = ($vr);
    my @cv = $G->successors($vr);
    my $l = $G->all_reachable($vr) + 1;

    foreach (@cv) {             # one or two directions
        @path = reverse @path;  # second dir in other dir
        my $cv = $_;            # current
        push @path, $cv;

        my $pv = $vr;           # prev
        while (my $nv = next_vertex($G, $cv, $pv)) {
            push @path, $nv;
            $pv = $cv;
            $cv = $nv;

            die "inf loop" if @path > $l;
        }
    }

    #    print Dumper($vr, \@cv, [@path]);
    return @path;
}

sub next_vertex{
    my ($G, $cv, $pv) = @_;
    my @s = $G->successors($cv);
    if (@s < 2) {
        # no successor but previous
        return undef;
    } elsif (@s > 2) {
        die "junction (degree: ".@s.") at $cv\n";
    }

    return $s[0] eq $pv ? $s[1] : $s[0];
}

##----------------------------------------------------------------------------##
# supplementary

sub bin{
    my ($bin) = @_;
    if (exists $opt{$bin."_path"}) {
        return $opt{$bin."_path"}."/".$bin;
    } else {
        return $bin;
    }
}

sub check_binary{
    my($bin, $ver) = (@_);
    my $fbin = $bin;
    unless(-e $fbin && -x $fbin){
        if ($fbin = which($bin)) {
            $L->logdie("Binary '$fbin' not executable") unless -e $fbin && -x $fbin;
        } else {
            $L->logdie("Binary '$bin' neither in PATH nor executable");
        }
    }

    $bin = basename($fbin);

    my $v;
    if ($ver) {
        $L->logdie("ARRAY ref required") unless ref $ver eq "ARRAY";

        my $vs = qx($fbin $ver->[0]);
        if ($? or ! $vs) {
            $L->logdie("Couldn't determine version of $bin, at least $ver->[1] required");
        }

        ($v) = $vs =~ /(\S+?)\D*$/m;

        if (version->parse($v) < version->parse($ver->[1])) {
            $L->logdie("Version $v of '$bin' < $v");
        }

    }

    $L->info(sprintf("  [ok] %-15s %s", $bin.($v ? "-$v" : ""), dirname($fbin)));

}


sub read_frg{
    my $file = shift;
    my $fp = Fasta::Parser->new(file => $file)->check_format;
    $fp = Fastq::Parser->new(file => $file)->check_format unless $fp;
    $L->logdie("Input neither FASTA nor FASTQ\n ($file)") unless $fp;

    my %frg;
    while (my $fa = $fp->next_seq) {
        die "non-unique ID: ".($fa->id)."\n" if exists $frg{$fa->id};
        $frg{$fa->id} = $fa;
    }
    return %frg;
}

=head2 graph2sif

print .sif representation of graph for Cytoscape

=cut

sub graph2sif{
    my ($g, $sif) = @_;

    $L->info("Dumping sif ($sif)");
    open(SIF, ">$sif") or die "$!: $sif";
    foreach($g->edges){
        my ($v1,$v2) = @$_;
        my %ovl = %{$g->get_edge_attribute($v1, $v2, "ovl")};
        my $edge = sprintf("%s-[%s]-%s-[%s]-%s",
            $ovl{adir},
            join(",", @{$ovl{aoff}}),
            $ovl{score},
            join(",", @{$ovl{boff}}),
            $ovl{bdir});

        print SIF "$v1 $edge $v2\n";
    }
    close SIF;
}
